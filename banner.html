<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
    <style type="text/css">
    #three {
        width: 800px;
        height: 500px;
    }
    </style>
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="stats.min.js"></script>
</head>

<body>
    <div id="three"></div>
    <div id="Stats-output"></div>
</body>
<script type="text/javascript">
var scene;
var stats = initStats();
var width = $("#three").width();
var height = $("#three").height();

function initStats() {
    var stats = new Stats();
    //设置统计模式
    stats.setMode(0); // 0: fps, 1: ms
    //统计信息显示在左上角
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    //将统计对象添加到对应的<div>元素中
    document.getElementById("Stats-output").appendChild(stats.domElement);
    return stats;
}

function initScene() {
    scene = new THREE.Scene();
}

var camera;

function initCamera() {
    camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    // camera = new THREE.OrthographicCamera(width/-2,width/2,height/-2,height/2,1, 1000);
    // camera = new THREE.PerspectiveCamera(75, $("#three").width() / $("#three").height(), 0.1, 1000);
    camera.position.z = 300;
    camera.lookAt(0, 0, 200)
}
function getpoints(){
    var startx=Math.cos(Math.PI*3/4)*(Math.random()*70-135);
    var starty=Math.random()*90-45;
    var startz=Math.sin(Math.PI*3/4)*(Math.random()*2 -1)-30;
    
    var stopx=Math.cos(Math.PI*3/4)*(Math.random()*70+65);
    var stopy=Math.random()*90-45;
    var stopz=Math.cos(Math.PI*3/4)*(Math.random()*2 -1);

    var middlex=Math.random()*(stopx-startx)+startx;
    var middley=Math.random()*(stopy-starty)+starty;
    var middlez=Math.random()*(stopz-startz)+startz;

    console.log([[startx,starty,startz],[middlex,middley,middlez],[stopx,stopy,stopz]])
    return [[startx,starty,startz],[middlex,middley,middlez],[stopx,stopy,stopz]];
}

var leftbox;

function addLeftBox() {
    var geometry = new THREE.BoxBufferGeometry(70, 90, 1, 4, 4, 4);
    var material = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, wireframe: false, opacity: 1, side: THREE.DoubleSide });
    leftbox = new THREE.Mesh(geometry, material);
    leftbox.rotation.y = -Math.PI / 4;
    leftbox.position.x = -100;
    leftbox.position.z = -30;
    scene.add(leftbox);
}

var rightbox;

function addRightBox() {
    var geometry = new THREE.BoxBufferGeometry(70, 90, 5, 4, 4, 4);
    var material = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, wireframe: false, opacity: 1, side: THREE.DoubleSide });
    rightbox = new THREE.Mesh(geometry, material);
    rightbox.rotation.y = -Math.PI / 4;
    rightbox.position.x = 100;
    scene.add(rightbox);
}

var alpha = 'abcdefghijklmnopqrstuvwxyz'.split('');

function getwords() {
    var l = parseInt(Math.random() * 5 + 5);
    var word = '';
    for (var i = 0; i < l; i++) {
        var w = alpha[parseInt(Math.random() * 26)];
        word = word + w;
    }
    return word + ' ';
}



function addText() {
    var loader = new THREE.FontLoader();
    loader.load('font.json', function(font) {
        var geometry = new THREE.TextGeometry(getwords(), {
            font: font,
            size: 5,
            height: 1,
            // curveSegments: 12,
            // bevelEnabled: true,
            // bevelThickness: 1,
            // bevelSize: 10,
            // bevelSegments: 5
        });
        var material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: false });
        var text = new THREE.Mesh(geometry, material);
        scene.add(text);
    });
}

function addCurve() {
    var points=getpoints();
    var curve = new THREE.SplineCurve([
        new THREE.Vector3(points[0][0],points[0][1],points[0][2]),
        new THREE.Vector3(points[1][0],points[1][1],points[1][2]),
        new THREE.Vector3(points[2][0],points[2][1],points[2][2])
    ]);
    var points = curve.getPoints(50);
    var geometry = new THREE.BufferGeometry().setFromPoints(points);
    var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
    var splineObject = new THREE.Line(geometry, material);
    scene.add(splineObject);
}

var renderer;

function initRenderer() {
    renderer = new THREE.WebGLRenderer({ antialias: true, clearAlpha: 1 });
    renderer.setSize($("#three").width(), $("#three").height());
    renderer.setClearColor(new THREE.Color('rgb(71, 75, 159)'));
    $("#three").append(renderer.domElement);
}

var light;

function initLight() {
    light = new THREE.DirectionalLight(0xffffff);
    light.position.set(-100, 0, 404);
    scene.add(light);
}

function initAll() {
    initScene();
    initCamera();
    initRenderer();
    var axes = new THREE.AxisHelper(300);  
    // axes.rotation.y=Math.PI/4;

    scene.add(axes);  
    addCurve();
    addLeftBox();
    addRightBox();
    addText();
    initLight();
    renderer.render(scene, camera)
}
initAll();
var up = true;

function animate() {
    requestAnimationFrame(animate);
    stats.update();
    scene.rotation.y+=0.01
    // earths.rotation.y += 0.005
    // earths.rotation.x += 0.005;

    // earthcircle.forEach(function(ele) {
    //     ele.rotation.y += ele.rotationspeed
    //     ele.rotation.x += ele.rotationspeed
    //     ele.rotation.z += ele.rotationspeed
    // })

    // cubes.forEach(function(ele, i) {
    //     ele.position.y -= 0.2 * (ele.position.y > 0 ? 1 : -1)
    //     ele.position.x -= 0.2 * (ele.position.x > 0 ? 1 : -1)
    //     ele.position.z -= 0.2 * (ele.position.z > 0 ? 1 : -1)
    //     if (Math.sqrt(ele.position.y * ele.position.y + ele.position.x * ele.position.x + ele.position.z * ele.position.z) <= 70) {
    //         earths.add(ele);
    //         cubes.splice(i, 1);
    //     }
    // })
    // if (Math.random() > 0.99) {
    //     addCube();
    // }
    // earth.rotation.z+=0.01    
    // box.rotation.y+=0.01
    // box.rotation.x+=0.01
    // sphere.rotation.y-=0.01
    // sphere.rotation.x-=0.01
    // circle.rotation.y-=0.02
    // circle.rotation.x-=0.02
    // circle.rotation.z-=0.02
    renderer.render(scene, camera);
}
animate();
</script>

</html>