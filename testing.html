<!DOCTYPE html>
<html>

<head>
    <title></title>
    <style type="text/css">
    #three {
        width: 100%;
        height: 600px;
        float: left;
        background: blue;
    }

    #canvas {
        width: 300px;
        height: 300px;
        display: none;
    }
    </style>
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="Lensflare.js"></script>
    <script type="text/javascript" src="QuickHull.js"></script>
    <script type="text/javascript" src="CanvasRenderer.js"></script>
    <script type="text/javascript" src="Projector.js"></script>
    <script type="text/javascript" src="SceneUtils.js"></script>
    <script type="text/javascript" src="ConvexGeometry.js"></script>
    <script type="text/javascript" src="BufferGeometryUtils.js"></script>
    <!-- <script type="text/javascript" src="tweenjs.min.js"></script> -->
    <script type="text/javascript" src="Tween.js"></script>
    <!-- <script type="text/javascript" src="inflate.js"></script> -->
    <script type="text/javascript" src="FBXLoader.js"></script>
    <script type="text/javascript" src="OBJLoader.js"></script>
    <script type="text/javascript" src="OrbitControls.js"></script>
    <script type="text/javascript" src="stats.min.js"></script>
    <script type="text/javascript" src="dat.gui.js"></script>
</head>

<body>
    <div id="three"></div>
    <canvas id='canvas' width='300px' height='300px'></canvas>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=">
    <div id="Stats-output"></div>
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float u_time;
        varying vec3 color;
        void main() {
            gl_PointSize = 10.0;
            vec3 p=vec3(position.x,position.y*cos(u_time),position.z*sin(u_time));
            gl_Position = vec4(p, 1.0 );
            color= vec3(1.0*p.z,1.0*(1.0-p.z),1.0*p.y);
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float u_time; 
        varying vec3 color;
        void main(){ 
            //vec2 st = gl_FragCoord.xy/u_resolution.xy;
            //vec3 color=vec3(sin(u_time),cos(u_time+0.5),0.0);
            gl_FragColor=vec4(color,1.0); 
        }
    </script>
</body>
<script type="text/javascript">
(function(root) {
    function FThree(el) {
        this.$el = $(el);
        this.size = { width: $(el).width(), height: $(el).height() };
        this.uniforms={
            u_time: { type: "f", value: 1.0 }
        };
        this.cubelength = 0;
        this.scene = null;
        this.renderer = null;
        this.light = null;
        this.camera = null;
        this.obj = null;
        this.stat = this._initstat();
        this.eventlists = [];
        this.width = 200;
        this.length = 300;
        this.pointsize = 0.1;
        this.imgdata = null;
        this.controls = null;
        this.stari = 0;
        this.earth=new THREE.Group();
        this.init();

    }
    FThree.prototype = {
        init: function() {
            this._initrenderer();
            this._initscene();
            var axes = new THREE.AxisHelper(20);
            this.scene.add(axes);
            this.scene.add(this.earth);
            this._initcamera();
            // this._initaxis();
            // this._addobj();
            // this.addplane();
            // this.addsphere();
            // this.addcube();
            // this._initlight();
            this.addambientlight();
            this.addpointlight();
            this.addspotlight();
            // this.addlensflare();
            // this.addconvexgeo();
            // this.addlathegeo();
            // this.addparticle();
            // this.addplanegeo();
            // this.addparticleobj();
            // this.addmergeobj();
            // this.addTorusKnotGeometry();
            // this.addnormalsphere();
            // this.addmeshfase();
            // this.addhemilight();
            // this.addPointSphere();
            // this.addRobot();
            // this.updatetween();
            // this.testBlending();
            // this.getearthtexture();
            this.addwireframeobj();
            // this.getpositiondedpoints();
            this.getimgdata();
            this.generateLine(this.width);
            this.addshadergeo();
            // this.generatestars();
            // this.addraderlight();
            // this.TestPropaties();
            // this.addclipbox();
            // this.updaterobot();
            // this.robotpositionchange();
            this._render();
            this._initcontrols();

            this._addevent();
            // this.trigger('init')
            // console.log(this.scene)
            this.animate();
        },
        addshadergeo:function(){
            var vertices = [
                // 0.5,  0.5,  0.5,//顶点0
                // -0.5,  0.5,  0.5,//顶点1
                // 0.5, -0.5,  0.5,//顶点3
                // -0.5, -0.5,  0.5,//顶点2
                new THREE.Vector3(0.5,0.5,0.5),
                new THREE.Vector3(-0.7,0.5,-0.5),
                new THREE.Vector3(-0.5,-0.5,0.5),
                new THREE.Vector3(0.5,-0.5,1.0)
            ];
            var faces=[
                new THREE.Face3(0,1,2),
                new THREE.Face3(2,3,0)
                ]
            //类型数组格式顶点数据转为BufferAttribute对象
            // var verticesPosition = new THREE.BufferAttribute( vertices, 3 );
            var geometry = new THREE.Geometry();//缓冲几何对象
            //顶点数据关联着色器程序
            // geometry.addAttribute('position',verticesPosition);
            geometry.vertices=vertices;
            geometry.faces=faces;
            geometry.computeFaceNormals();
            // geometry.computeVertexNormals();
            console.log(geometry);

            var geometrybox=new THREE.BoxGeometry(0.3,0.3,0.3);
            console.log(geometrybox)
            var material = new THREE.ShaderMaterial( {
                uniforms: this.uniforms,
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent
                } );
            // material=new THREE.MeshBasicMaterial({color:0xffff00});
            var pointcloud = new THREE.Mesh(geometrybox, material);
            this.scene.add(pointcloud);
        },
        addstars: function() {
            var spriteMap = new THREE.TextureLoader().load("img/snow.png");
            var spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap, color: 0xffffff });
            var sprite = new THREE.Sprite(spriteMaterial);
            sprite.name='snow'+this.stari;
            sprite.random=Math.random()*2-1;
            this.scene.add(sprite);
            this.stari++;
            console.log(this.stari)
        },
        generatestars:function(){
            for(var i=0;i<100;i++){
                this.addstars();
            }
        },
        addraderlight: function(a, b,c) {
            var texture = new THREE.TextureLoader().load('earth/lightray_yellow.jpg');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            // var geometry = new THREE.CylinderBufferGeometry( 5, 5, 20, 32);
            var geometry = new THREE.PlaneBufferGeometry(this.width * 0.0038, this.width * 0.08 / 4, 32);
            var material = new THREE.MeshBasicMaterial({ alphaMap: texture, transparent: true, side: THREE.DoubleSide });
            var cylinder = new THREE.Mesh(geometry, material);
            var R = (this.width * 0.08 + this.width * 0.08 / 8);
            var cylinder1 = cylinder.clone();
            // this.rotateAroundWorldAxis(cylinder1,new THREE.Vector3( 1, 0, 0 ),a)
            // this.rotateAroundWorldAxis(cylinder1,new THREE.Vector3( 0, 1, 0 ),b)
            // this.rotateAroundWorldAxis(cylinder1,new THREE.Vector3( 0, 0, 1 ),c)
            cylinder1.position.set(0,-R,0)
            var positions=this.rotate(0,-R,0,a,b,0)
            // cylinder1.position.set(positions[0],positions[1],positions[2])
            var group=new THREE.Object3D();
            group.add(cylinder1);
            group.rotateX(a)
            group.rotateY(b)
            group.rotateZ(c)
            // cylinder1.rotateZ(0)
            // cylinder1.rotateOnWorldAxis(new THREE.Vector3( 1,0,0 ),a)
            // cylinder1.rotateY(b)
            // console.log(a, b)
            this.earth.add(cylinder);
            this.earth.add(group);

        },
         rotateAroundWorldAxis:function(object, axis, radians) {
        rotWorldMatrix = new THREE.Matrix4();
        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
        rotWorldMatrix.multiply(object.matrix);                // pre-multiply
        object.matrix = rotWorldMatrix;
        object.rotation.setFromRotationMatrix(object.matrix);
        },
        rotatex:function(x,y,z,a){
            // console.log([x,y*Math.cos(a)-z*Math.sin(a),y*Math.sin(a)+z*Math.cos(a)])
            return [x,y*Math.cos(a)-z*Math.sin(a),y*Math.sin(a)+z*Math.cos(a)]
        },
        rotatey:function([x,y,z],b){
            // console.log('y',[x*Math.cos(b)-z*Math.sin(b),y,-x*Math.sin(b)+z*Math.cos(b)])
            return [x*Math.cos(b)-z*Math.sin(b),y,-x*Math.sin(b)+z*Math.cos(b)]
        },
        rotatez:function([x,y,z],c){
            // console.log('z',[x*Math.cos(c)-y*Math.sin(c),x*Math.sin(c)+y*Math.cos(c),z])
            return [x*Math.cos(c)-y*Math.sin(c),x*Math.sin(c)+y*Math.cos(c),z]
        },
        rotate:function(x,y,z,a,b,c){
            var angles=[];
            var that=this;
            angles=that.rotatez(that.rotatey(that.rotatex(x,y,z,a),b),c);
            // console.log(angles);
            return angles
        },
        addwireframeobj: function() {
            var sphereaircircleobj = new THREE.SphereBufferGeometry(this.width * 0.08 * 1.2, 32, 32);
            var sphereaircircle = new THREE.TextureLoader().load("earth/clouds.jpg");
            var aircirclematerial = new THREE.MeshBasicMaterial({ transparent: true, side: THREE.FrontSide, alphaMap: sphereaircircle, color: new THREE.Color('rgb(19, 47, 38)'), opacity: 1, depthTest: !1, depthWrite: !1, clippingPlanes: [new THREE.Plane(new THREE.Vector3(0, 0, this.width * 0.08 * 1.2), 1)] });
            var aircircle = new THREE.Mesh(sphereaircircleobj, aircirclematerial);
            this.earth.add(aircircle);
        },
        getimgdata: function() {
            var that = this;
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var img = new Image();
            img.src = 'earth/earth_1.png';
            img.onload = function() {
                canvas.width = that.length;
                canvas.height = that.length;
                ctx.drawImage(img, 0, 0, that.length, that.length);
                that.imgdata = ctx.getImageData(0, 0, that.length, that.length);
                var k = 0,
                    k1 = 0;
                for (var i = 0; i < that.length; i++) {
                    for (var j = 0; j < that.length; j++) {
                        if (that.imgdata.data[(i * that.length + j) * 4 + 0] == 0 && that.imgdata.data[(i * that.length + j) * 4 + 1] == 0 && that.imgdata.data[(i * that.length + j) * 4 + 2] == 0) {
                            k++;
                        } else {
                            k1++;
                        }
                    }
                }
                console.log(that.imgdata, k)
                var pcBuffers = that.generatePointcloud(new THREE.Color(1, 0, 0), that.width, that.length, k, k1);
                var pcBuffer = pcBuffers[0];
                var angles = pcBuffers[1];

                pcBuffer.scale.set(.08, .08, .08);
                pcBuffer.position.set(0, 0, 0);
                that.earth.add(pcBuffer);

                var linesize = 5;
                var trangsize = linesize - 2;
                var r = 0.6;
                var R = that.width * 0.08;
                var circlegeometry = new THREE.Geometry();
                var positions = new Float32Array(linesize * 3);
                for (var i = 0; i < linesize; i++) {
                    var a = r / R;
                    var b = i * Math.PI * 2 / linesize;
                    positions[i * 3] = Math.sin(a) * Math.sin(b) * R;
                    positions[i * 3 + 1] = Math.cos(a) * R;
                    positions[i * 3 + 2] = Math.sin(a) * Math.cos(b) * R;
                    circlegeometry.vertices.push(new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]))
                }
                for (var j = 0; j < trangsize; j++) {
                    circlegeometry.faces[j] = new THREE.Face3(0, j + 1, j + 2)
                }
                var circlegroup = new THREE.Group();

                var material1 = new THREE.ShaderMaterial( {
                uniforms: that.uniforms,
                // vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent
                } );
                // var material1 = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.FrontSize });
                var linematerial = new THREE.LineBasicMaterial({ color: new THREE.Color('rgb(29, 95, 68)'), side: THREE.DoubleSide });
                var circlemesh = new THREE.Mesh(circlegeometry, material1);
                var groupgeometry = new THREE.Geometry();
                var linegroup = new THREE.Group();
                for (var i = 0; i < angles.length / 2; i++) {
                    var circle = circlegeometry.clone();
                    circle.rotateX(angles[i * 2]);
                    circle.rotateY(angles[i * 2 + 1]);
                    groupgeometry.vertices = groupgeometry.vertices.concat(circle.vertices);
                    linegroup.add(new THREE.LineLoop(circle, linematerial));
                    for (var j = 0; j < trangsize; j++) {
                        groupgeometry.faces[i * trangsize + j] = new THREE.Face3(i * linesize, i * linesize + j + 1, i * linesize + j + 2)
                    }
                    if (i % 5==0) {
                        var b = angles[i * 2 + 1];
                        var a = angles[i * 2] > Math.PI / 2 ? (Math.PI / 2 - angles[i * 2]) : (Math.PI / 2 + angles[i * 2])
                        var z = R * Math.sin(a) * Math.cos(b);
                        var x = R * Math.sin(a) * Math.sin(b);
                        var y = R * Math.cos(a);
                        that.addraderlight(angles[i * 3], angles[i * 3 + 1], angles[i * 3 + 2])
                    }
                }
                var groupcirclemesh = new THREE.Mesh(groupgeometry, material1);
                var grouplinemesh = new THREE.Line(groupgeometry, linematerial);
                that.earth.add(linegroup);
                // that.scene.add( grouplinemesh );
            }
        },
        generatePointCloudGeometry: function(color, width, length, plength, klength) {
            var that = this;
            var geometry = new THREE.BufferGeometry();
            var positions = new Float32Array(plength * 3);
            var colors = new Float32Array(plength * 3);
            var angles = new Float32Array(100 * 2);
            var k = 0,
                k1 = 0;

            for (var i = 0; i < length; i++) {
                for (var j = 0; j < length; j++) {
                    var a = i * Math.PI / length;
                    var b = j * 2 * Math.PI / length; //什么玩意，不会算了这东西
                    var z = width * Math.sin(a) * Math.cos(b);
                    var x = width * Math.sin(a) * Math.sin(b);
                    var y = width * Math.cos(a);
                    if (that.imgdata.data[(i * length + j) * 4 + 0] == 0 && that.imgdata.data[(i * length + j) * 4 + 1] == 0 && that.imgdata.data[(i * length + j) * 4 + 2] == 0) {
                        positions[3 * k] = x;
                        positions[3 * k + 1] = y;
                        positions[3 * k + 2] = z;
                        k++;
                    } else {

                        if (Math.random() < 0.001 && k1 < 100) {
                            angles[k1 * 3] = a;
                            angles[k1 * 3 + 1] = b;
                            angles[k1 * 3 + 2] = b;
                            k1++;
                        }
                    }
                }
            }
            geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeBoundingBox();
            return [geometry, angles];

        },
        generatePointcloud: function(color, width, length, k, k1) {
            var canvasstar = new THREE.CanvasTexture(this.generateStar());
            var geometrys = this.generatePointCloudGeometry(color, width, length, k, k1)
            var geometry = geometrys[0];
            var angles = geometrys[1];

            // var material = new THREE.PointsMaterial({ size: this.pointsize, side: THREE.DoubleSide, color: new THREE.Color('rgb(29, 95, 68)'), depthTest: !1, depthWrite: !1, transparent: true });

            var material = new THREE.ShaderMaterial( {
                uniforms: this.uniforms,
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent
                } );
            var pointcloud = new THREE.Points(geometry, material);
            this.scene.add(pointcloud);
            return [pointcloud, angles];

        },
        generateStar: function() {
            var canvas = document.createElement('canvas');
            var cxt = canvas.getContext('2d');
            cxt.save();
            cxt.translate(100, 80);
            cxt.beginPath();
            cxt.strokeStyle = "orange";
            cxt.lineWidth = "10";
            cxt.closePath();
            cxt.beginPath();
            for (var i = 0; i < 5; i++) {
                cxt.lineTo(100 * Math.cos((18 + i * 72) * Math.PI / 180), -100 * Math.sin((18 + i * 72) * Math.PI / 180));
                cxt.lineTo(50 * Math.cos((54 + i * 72) * Math.PI / 180), -50 * Math.sin((54 + i * 72) * Math.PI / 180));
            }
            cxt.fillStyle = "yellow";
            cxt.fill();
            cxt.closePath();
            cxt.stroke();
            cxt.restore();
            return canvas;
        },
        generateLine: function(width) {
            var contour = new THREE.TextureLoader().load('earth/contour.png');
            var geometry = new THREE.SphereBufferGeometry(width, 32, 32);

            var material = new THREE.MeshBasicMaterial({ alphaMap: contour, side: THREE.DoubleSide, color: 0xffff00, transparent: true, depthTest: 0, depthWrite: 0 });
            var line = new THREE.Mesh(geometry, material);
            line.scale.set(.08, .08, .08);
            line.position.set(0, 0, 0);
            line.rotation.set(0, -Math.PI / 2, 0)
            this.earth.add(line);
        },
        getpositiondedpoints: function() {
            var starsGeometry = new THREE.Geometry();
            for (var i = 0; i < 10000; i++) {
                var star = new THREE.Vector3();
                star.x = THREE.Math.randFloatSpread(10);
                star.y = THREE.Math.randFloatSpread(10);
                star.z = THREE.Math.randFloatSpread(10);
                starsGeometry.vertices.push(star);
                starsGeometry.colors.push(0x00ff00);
            }
            starsGeometry.colors.NeedUpdate = true;
            var starsMaterial = new THREE.PointsMaterial();

            var starField = new THREE.Points(starsGeometry, starsMaterial);
            this.scene.add(starField);
        },
        addclipbox: function() {
            var geometry = new THREE.BoxGeometry(8, 8, 8);
            var material = new THREE.MeshPhongMaterial({ color: 0xff0100, clippingPlanes: [new THREE.Plane(new THREE.Vector3(0, 1, 0), 1)] });
            var box = new THREE.Mesh(geometry, material);
            box.castShadow = true;
            this.scene.add(box);
        },
        TestPropaties: function() {
            var clipPlanes = [
                new THREE.Plane(new THREE.Vector3(0, -5, 0), 0.8),
                new THREE.Plane(new THREE.Vector3(0, 1, 0), 0.8)
            ];
            // console.log(new THREE.Plane(new THREE.Vector3(1, 0, 0), 0))
            var geo1 = new THREE.BoxGeometry(5, 5, 5);
            var geo2 = new THREE.TorusKnotBufferGeometry(10, 1.8, 950, 200);
            var mat1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            // var mat2=new THREE.MeshLambertMaterial( {color:0x00ff00,transparent:true,opacity:.5,depthTest:1,AlphaTest:0,side:THREE.DoubleSide,clipIntersection: true,clippingPlanes:clipPlanes,depthWrite: !1} );
            var mat2 = new THREE.MeshPhongMaterial({
                color: 0x80ee10,
                shininess: 100,
                side: THREE.DoubleSide,
                // ***** Clipping setup (material): *****
                clippingPlanes: clipPlanes,
                clipShadows: true
            });
            var mesh1 = new THREE.Mesh(geo1, mat1);
            mesh1.position.z = -6;
            var mesh2 = new THREE.Mesh(geo2, mat2);
            this.scene.add(mesh1)
            this.scene.add(mesh2)
        },
        getearthtexture: function() {
            var that = this;
            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');
            var star = new Image();
            star.src = 'earth/star.png';
            var stardata;
            star.onload = function() {
                var canvas1 = document.createElement('canvas');
                canvas1.width = star.width;
                canvas1.height = star.height;
                document.body.append(canvas1)
                var ctx1 = canvas1.getContext('2d');
                ctx1.drawImage(star, 0, 0);
                stardata = ctx1.getImageData(0, 0, canvas1.width, canvas1.height).data;
                var img = new Image();
                img.src = 'earth/earth_1.png';
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    var imgdata = ctx.getImageData(0, 0, img.width, img.height);
                    for (var i = 0; i < imgdata.data.length; i += 4) {
                        imgdata.data[i] = imgdata.data[i] | stardata[i % stardata.length];
                        imgdata.data[i + 1] = imgdata.data[i + 1] | stardata[(i + 1) % stardata.length];
                        imgdata.data[i + 2] = imgdata.data[i + 2] | stardata[(i + 2) % stardata.length];
                        if (imgdata.data[i] >= 200 && imgdata.data[i + 1] >= 200 && imgdata.data[i + 2] >= 200) {
                            imgdata.data[i + 3] = 0;
                        } else if (imgdata.data[i] == 0 && imgdata.data[i + 1] == 0 && imgdata.data[i + 2] == 0) {
                            imgdata.data[i + 3] = 0;
                        }
                    }
                    ctx.putImageData(imgdata, 0, 0);
                    that.earthctx = new THREE.CanvasTexture(canvas);
                    that.addctxSphere();
                }
            }
        },

        addctxSphere: function() {
            var that = this;
            var geometry = new THREE.SphereGeometry(10, 64, 64);
            var material = new THREE.MeshBasicMaterial({
                    map: that.earthctx,
                    transparent: !0,
                    opacity: 1,
                    color: new THREE.Color(16777215),
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: !1
                }

            );
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 10;
            this.scene.add(mesh)
            this._render();
        },
        testBlending: function() {
            var that = this;
            var loader = new THREE.JSONLoader().load('earth/station_b.js', function(geometry, materials) {
                var material = materials[0];
                var object = new THREE.Mesh(geometry, material);
                that.scene.add(object);
            });
            var loader = new THREE.JSONLoader().load('earth/station_c.js', function(geometry, materials) {
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var object = new THREE.Mesh(geometry, material);
                that.scene.add(object);
            });
            // this.scene.add(loader);
        },
        addRobot: function() {
            var that = this;
            new THREE.OBJLoader().load('models/Santa Claus Pose1/Santa_Claus_Pose1_obj.obj', function(obj) {
                var geometry = obj.children[0].geometry;
                // var material=new THREE.PointsMaterial({color:0xffff00,size:0.05});

                var uniforms = {
                    color: {
                        type: 'v3',
                        value: new THREE.Color(0xffffff)
                    }
                };
                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                })
                // console.log(shaderMaterial)
                var robot = new THREE.Points(geometry, shaderMaterial);
                robot.scale.x = 0.1;
                robot.scale.y = 0.1;
                robot.scale.z = 0.1;
                robot.rotation.x = -Math.PI / 2;
                that.robot = robot;
                // that.scene.add(robot)
                that._render();
                that.robotpositionchange();

            });
        },
        updaterobot: function() {
            // TWEEN.update();
            this.stat.update();
            var time = new Date() * 0.005;
            if (this.robot) {
                var obj = this.robot.geometry;
                // console.log(obj)
                var sizes = obj.attributes.position.array;
                var len = sizes.length;
                for (var i = 0; i < len; i++) {
                    sizes[i] = sizes[i] + 0.1;
                }
                obj.attributes.position.needsUpdate = true;
            }
            this._render();
            requestAnimationFrame(this.updaterobot.bind(this))
        },
        robotpositionchange: function() {

            var moreObj = this.robot.geometry;
            moreObj.scale.x = 0.1;
            moreObj.scale.y = 0.1;
            moreObj.scale.z = 0.1;
            // moreObj.rotation.x = -Math.PI / 2;
            var lessObj = this.pointsphere;
            if (moreObj.attributes.position.array.length < lessObj.attributes.position.array.length) {
                [moreObj, lessObj] = [lessObj, moreObj];
            }
            var morePos = moreObj.attributes.position.array;
            var lessPos = lessObj.attributes.position.array;
            var moreLen = moreObj.attributes.position.array.length;
            var lessLen = lessObj.attributes.position.array.length;
            // console.log(moreLen)
            // console.log(lessLen)
            var position2 = new Float32Array(moreLen);
            position2.set(lessPos);

            for (var i = lessLen, j = 0; i < moreLen; i++, j++) {
                j %= lessLen;
                position2[i] = lessPos[j];
                position2[i + 1] = lessPos[j + 1];
                position2[i + 2] = lessPos[j + 2];
            }

            var sizes = new Float32Array(moreLen);
            for (var i = 0; i < moreLen; i++) {
                sizes[i] = 4;
            }
            moreObj.addAttribute('size', new THREE.BufferAttribute(sizes, 1));
            moreObj.addAttribute('position2', new THREE.BufferAttribute(position2, 3));
            moreObj.attributes.position.needsUpdate = true;
            moreObj.attributes.position2.needsUpdate = true;
            var uniforms = {
                color: {
                    type: 'v3',
                    value: new THREE.Color(0xffffff)
                },
                val: {
                    value: 1.0
                }
            };

            var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false, // 这个不设置的话，会导致带透明色的贴图始终会有方块般的黑色背景
                transparent: true
            });
            var particleSystem = new THREE.Points(moreObj, shaderMaterial);
            var pos = { val: 1 };
            var tween = new TWEEN.Tween(pos).to({
                val: 0
            }, 1500).easing(TWEEN.Easing.Quadratic.InOut).delay(1000).onUpdate(function(val) {
                particleSystem.material.uniforms.val.value = val;
                // console.log(val)
            });
            var tweenBack = new TWEEN.Tween(pos).to({
                val: 1
            }, 1500).easing(TWEEN.Easing.Quadratic.InOut).delay(1000).onUpdate(function(val) {
                particleSystem.material.uniforms.val.value = val;
                // console.log(val)
            });
            tween.chain(tweenBack);
            tweenBack.chain(tween);
            tween.start();

            this.scene.add(particleSystem);
            this.particleSystem = particleSystem;

        },
        updatetween: function() {
            requestAnimationFrame(this.updatetween.bind(this))
            this._render();
            // console.log(this.scene)
            TWEEN.update();
        },

        addPointSphere: function() {
            var material = new THREE.PointsMaterial({ color: 0xff55ca, size: 0.1, morphTargets: true });
            var geomatry = new THREE.SphereBufferGeometry(3, 32, 32);
            var uniforms = {
                color: {
                    type: 'v3',
                    value: new THREE.Color(0xffffff)
                }
            };
            var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            })
            this.pointsphere = geomatry;
            var mesh = new THREE.Points(geomatry, shaderMaterial)
            mesh.position.y = 4;
            // console.log(mesh)
            this.scene.add(mesh);
        },
        on: function(type, fn) {
            type = type || 'any';
            if (typeof this.eventlists[type] === "undefined") {
                this.eventlists[type] = [];
            }
            this.eventlists[type].push(fn);
        },
        trigger: function(type) {
            var l = this.eventlists[type].length;
            var returndata;
            for (var i = 0; i < l; i++) {
                returndata = this.eventlists[type][i].call(this);
            }
            return returndata;
        },
        _initstat: function() {
            var stats = new Stats();
            //设置统计模式
            stats.setMode(0); // 0: fps, 1: ms
            //统计信息显示在左上角
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            //将统计对象添加到对应的<div>元素中
            document.getElementById("Stats-output").appendChild(stats.domElement);
            return stats;
        },
        _initrenderer: function() {
            this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            this.renderer.setSize(this.size.width, this.size.height);
            this.renderer.setClearColor(0x000000)
            this.renderer.localClippingEnabled = true;
            this.renderer.shadowMap.enabled = true
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.shadowMapSoft = true;
            this.$el.append(this.renderer.domElement)
        },
        _initscene: function() {
            this.scene = new THREE.Scene();
            // this.scene.fog=new THREE.FogExp2( 0xff00ff,0.15 );//雾化效果
            // this.scene.overrideMaterial=new THREE.MeshLambertMaterial( {color:0xffffff,   wireframe:false });//所有物体一个颜色
        },
        _initaxis: function() {
            var option = {
                size: 5,
                height: 10,
                weight: 'normal',
                font: 'helvetiker'
            }
            var size = 1 * 2;
            var vectors = [];
            var texts = new THREE.Group();
            var loader = new THREE.FontLoader();
            var material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
            loader.load('font1.json', function(font) {
                for (var x = 0; x <= size; x++) {
                    for (var y = x; y <= size; y++) {
                        for (var z = y; z <= size; z++)
                            var geometry = new THREE.TextGeometry('1', {
                                font: font,
                                size: 0.1,
                                height: 0.1,
                                // curveSegments: 1,
                                // bevelEnabled: true,
                                bevelThickness: 0.01,
                                // bevelSize: 8,
                                // bevelSegments: 5
                            });
                        var text = new THREE.Mesh(geometry, material);
                        text.position.set(x - size, y - size, z - size)
                        texts.add(text)
                    }
                }
            });
            // console.log(texts)
            this.scene.add(texts);
        },
        _initcamera: function() {
            this.camera = new THREE.PerspectiveCamera(75, this.size.width / this.size.height, this.width * 0.08 * 1.05, 1000);
            this.camera.position.z = 30;
            this.camera.position.y = 15;
            this.camera.lookAt(0, 0, 0);
        },
        switchcamera: function() {
            if (this.camera instanceof THREE.PerspectiveCamera) {
                this.camera = new THREE.OrthographicCamera(this.size.width / -16, this.size.width / 16, this.size.height / -16, this.size.height / 16);
                this.camera.position.z = 15;
                this.camera.lookAt(0, 0, 0);
            } else {
                this.camera = new THREE.PerspectiveCamera(75, this.size.width / this.size.height, 0.1, 1000);
                this.camera.position.z = 15;
                this.camera.lookAt(0, 0, 0);
            }
            this._render();
        },
        _initlight: function() { //平行光
            this.light = new THREE.DirectionalLight({ color: 0xff00ff });
            // this.light.target = this.obj;
            this.light.castShadow = true;
            // this.light.shadowCameraVisible = true;
            this.light.shadowDarkness = 0.1;
            this.light.position.y = 2;
            this.light.position.x = 2;
            this.light.position.z = 2;
            this.light.shadow.mapSize.width = 128
            this.light.shadow.mapSize.height = 128
            this.scene.add(this.light);
        },
        addambientlight: function() {
            this.amlight = new THREE.AmbientLight(0x333333);
            this.amlight.position.set(2, 2, 3);
            this.amlight.intensity = 0.2;
            this.scene.add(this.amlight)
        },
        addpointlight: function() { //点光源
            this.pointlight = new THREE.PointLight({ color: 0xff0000, intensity: 2, distance: 2 });
            this.pointlight.position.set(2, 2, 2);
            this.pointlight.castShadow = false;
            this.pointlight.shadowDarkness = 0.1;
            this.pointlight.shadow.mapSize.width = 128
            this.pointlight.shadow.mapSize.height = 128
            this.scene.add(this.pointlight);
        },
        chageintensity: function(intensity) {
            this.pointlight.intensity = intensity;
        },
        addspotlight: function() { //聚光灯
            this.spotlight = new THREE.SpotLight(0xffffff);
            this.spotlight.position.set(50, 25, 15);
            this.spotlight.castShadow = true;
            this.spotlight.shadowDarkness = 1.1;
            this.spotlight.shadow.mapSize.width = 128
            this.spotlight.shadow.mapSize.height = 128
            var target = new THREE.Object3D();
            target.position = new THREE.Vector3(0, 0, 0);
            this.spotlight.target = target;
            this.scene.add(this.spotlight);
        },
        addhemilight: function() { //半球光
            this.hemilight = new THREE.HemisphereLight(0xff0000, 0x00ff00, 0.6);
            this.hemilight.position.set(0, 500, 0);
            this.scene.add(this.hemilight);
        },
        addarealight: function() { //平面光光源 从平面发射的光，太复杂了，要多加好多东西，先不看
            this.arealight = new THREE.AreaLight();

        },
        addlensflare: function() { //添加光晕
            var texture = new THREE.TextureLoader().load('lensflare0.png');

            this.lensflare = new THREE.Lensflare();
            this.lensflare.addElement(new THREE.LensflareElement(texture, 100, 0))
            this.lensflare.position = this.spotlight.position
            this.spotlight.add(this.lensflare);
        },
        addcube: function() {
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxBufferGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshPhongMaterial({ color: color, wireframe: false });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            // this.scene.add(cube);
            // this._render();
            return geometry;
            this.cubelength++;
        },
        addblendcube: function() {
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var depthmaterial = new THREE.MeshDepthMaterial();
            var colormaterial = new THREE.MeshBasicMaterial({ color: color, wireframe: false, transparent: true, blending: THREE.MultiplyBlending });
            var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry, [depthmaterial, colormaterial]);
            cube.children[0].scale.set(.99, .99, .99)
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        adddepthcube: function() { //深度着色，其外观由物体到相机距离决定，可以做成逐渐消失的样子,error
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshDepthMaterial({ fog: true });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        addlambercube: function() {
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshLambertMaterial({ color: color });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        addlphongcube: function() { //类似金属的材质
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshPhongMaterial({ color: color, specular: color, shininess: 100 });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        addnormalsphere: function() { //法向量材质，不太懂，反正颜色怎么转都一样,也不能设置颜色
            var geometry = new THREE.SphereGeometry(5, 32, 32);
            var material = new THREE.MeshNormalMaterial({ wireframe: false, shading: THREE.SmoothShading });
            var obj = new THREE.Mesh(geometry, material);
            obj.position.x = 3;
            obj.castShadow = true;
            this.scene.add(obj);
        },
        addshadercube: function() { //着色器材质，最复杂的材质，也是最有用的，后面详细看

        },
        addplanegeo: function() {
            var geometry = new THREE.PlaneGeometry(5, 5, 20);
            this.createMesh(geometry, 1, 1, 1);
        },
        addmeshfase: function() {
            var map = new THREE.TextureLoader().load('1.png');
            var map1 = new THREE.TextureLoader().load('b.png');
            map1.wrapS = THREE.RepeatWrapping;
            map1.wrapT = THREE.RepeatWrapping;
            map1.repeat.set(4, 4);
            var metarry = [];
            for (var i = 0; i < 6; i++) {
                metarry.push(new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, blending: THREE.MultiplyBlending, transparent: true }));
            }


            // var material=new THREE.MeshFaceMaterial( metarry );
            // var material=new THREE.MeshBasicMaterial({color:0xff0000,transparent:true});
            var material = new THREE.MeshBasicMaterial({ map: map1, transparent: true });
            material.blending = THREE.NormalBlending;
            material.blendEquation = THREE.SubtractEquation; //default
            material.blendSrc = THREE.SrcAlphaFactor; //default
            material.blendDst = THREE.OneMinusSrcAlphaFactor; //default
            var mapmaterial = new THREE.MeshBasicMaterial({ map: map })
            var depthmaterial = new THREE.MeshDepthMaterial();
            var geometry = new THREE.CubeGeometry(3, 3, 3);
            // var cube=new THREE.Mesh(geometry,material);
            var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry, [material, mapmaterial])
            cube.children[1].scale.set(0.99, 0.99, 0.99);
            cube.position.set(0, 0, 9);
            this.scene.add(cube);
        },
        createMesh: function(geometry, x, y, z) {
            var meshMaterial = new THREE.MeshNormalMaterial();
            meshMaterial.side = THREE.DoubleSide;
            var wireFrameMaterial = new THREE.MeshBasicMaterial({ wireframe: true, color: 0xff0000 });
            var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [meshMaterial, wireFrameMaterial]);
            // var mesh=new THREE.Mesh(geometry,wireFrameMaterial)
            mesh.position.set(x, y, z)
            this.scene.add(mesh);
        },
        removecube: function() {
            if (this.scene.children[this.cubelength - 1] instanceof THREE.Mesh) {
                this.scene.remove(this.scene.children[this.cubelength - 1])
                this._render();
                this.cubelength--;
            }
        },
        addsphere: function() {
            var geometry = new THREE.SphereGeometry(5, 32, 32);
            var material = new THREE.MeshPhongMaterial({ color: 0x00aa34, wireframe: false });
            var obj = new THREE.Mesh(geometry, material);
            obj.position.x = 3;
            obj.castShadow = true;
            this.scene.add(obj);
        },
        addplane: function() {
            var geometry = new THREE.BoxGeometry(50, 50, 0.1);
            var material = new THREE.MeshLambertMaterial({ color: 0xefefef, wireframe: false, side: THREE.DoubleSide });
            var cube = new THREE.Mesh(geometry, material);
            cube.receiveShadow = true;
            cube.rotation.x = Math.PI / 2;
            cube.position.y = -10;
            this.scene.add(cube);
        },
        addconvexgeo: function() { //画一个凸起的包
            var convexgeo = new THREE.ConvexGeometry(this.generatelathepoints());
            var material = new THREE.MeshPhongMaterial({ color: 0xff00ff, transparent: true, opacity: 0.2 });
            var mesh = new THREE.Mesh(convexgeo, material);
            this.scene.add(mesh);
        },
        addTorusKnotGeometry: function() {
            var geometry = new THREE.TorusKnotGeometry(5, 1, 100, 16);
            var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            var torusKnot = new THREE.Mesh(geometry, material);
            this.scene.add(torusKnot);
        },
        generatePoints: function() {
            var that = this;
            var points = [];
            for (var i = 0; i < 20; i++) {
                var x = -15 + Math.round(Math.random() * 30);
                var y = -15 + Math.round(Math.random() * 30);
                var z = -15 + Math.round(Math.random() * 30);
                points.push(new THREE.Vector3(x, y, z))
            }
            spGroup = new THREE.Object3D();
            var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            points.forEach(function(point) {
                var spGeom = new THREE.SphereGeometry(0.1);
                var spMesh = new THREE.Mesh(spGeom, material);
                spMesh.position.x = point.x;
                spMesh.position.y = point.y;
                spMesh.position.z = point.z;
                spMesh.name = point.x;
                spGroup.add(spMesh);
            });
            this.scene.add(spGroup);
            return points;
        },
        addlathegeo: function() { //根据点绘制平滑曲线
            var convexgeo = new THREE.LatheGeometry(this.generatelathepoints())
            var material = new THREE.MeshPhongMaterial({ color: 0xff00ff, transparent: true, opacity: 1 });
            var mesh = new THREE.Mesh(convexgeo, material);
            this.scene.add(mesh);
        },
        generatelathepoints: function() {
            var points = [];
            var height = 5;
            var count = 30;
            for (var i = 0; i < count; i++) {
                points.push(new THREE.Vector3((Math.sin(i * 1.2) + Math.cos(i * 1.3)) * height + 12, 0, (i - count) + count / 2));
            }
            return points;
        },
        addparticle: function() { //points 粒子
            // var starsGeometry = new THREE.Geometry();

            // for ( var i = 0; i < 100; i ++ ) {

            //     var star = new THREE.Vector3();
            //     star.x = THREE.Math.randFloatSpread( 100 );
            //     star.y = THREE.Math.randFloatSpread( 100 );
            //     star.z = THREE.Math.randFloatSpread( 100 );

            //     starsGeometry.vertices.push( star );

            // }

            var geometry = new THREE.SphereGeometry(1)
            var material = new THREE.PointsMaterial({ color: 0xffaa00 });
            for (var x = -5; x < 5; x++) {
                for (var y = -5; y < 5; y++) {
                    var particle = new THREE.Points(geometry, material);
                    particle.position.set(x * 3, y * 3, 0);
                    this.scene.add(particle);
                }
            }
            // this.on('init',this.addparticle);
        },
        addspirit: function() {
            var canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            var texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        },
        createpaticlesystem(geometry) {
            var material = new THREE.PointsMaterial({ color: 0xaacc22, size: 3, transparent: true, map: this.addspirit() });
            var system = new THREE.Points(geometry, material);
            // system.sortParticles=true;
            return system;
        },
        addparticleobj: function() { //把一个几何体用粒子画出来
            // var geometry=new THREE.TorusKnotGeometry( 30, 2, 8, 8, 2, 3 );
            // var knot=this.createpaticlesystem(geometry);
            // this.scene.add(knot);
            var map = new THREE.TextureLoader().load('img/earth_1.png');
            var colormaterial = new THREE.MeshBasicMaterial({ wireframe: false, transparent: true, blending: THREE.MultiplyBlending, map: map });

            var geometry = new THREE.TorusKnotGeometry(5, 1, 100, 16);
            // var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
            var material = new THREE.PointsMaterial({ color: 0xffcc22, size: 0.2, transparent: true, opacity: 0.5, map: map });
            // var torusKnot = new THREE.SceneUtils.createMultiMaterialObject(geometry, [material]);
            var torusKnot = new THREE.Points(geometry, material);
            // var torusKnot = new THREE.Mesh( geometry, material );
            this.scene.add(torusKnot);
        },
        addmergeobj: function() { //一次添加多个几何体，不知道怎么弄
            var geometries = new THREE.BoxBufferGeometry(2, 2, 2);
            // console.log(THREE.BufferGeometryUtils)
            for (var i = 0; i < 40; i++) {
                THREE.BufferGeometryUtils.mergeBufferGeometries([this.addcube()])
            }
            // console.log(geometries)
            var material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            var mesh = new THREE.Mesh(geometries, material);
            this.scene.add(mesh);
        },

        _addevent: function() {
            var that = this;
            var down = false;
            var position = {};
            $(document).mousedown(function(e) {
                down = true;
                position.x = e.clientX;
                position.y = e.clientY;
            })
            $(document).mousemove(function(e) {
                if (down) {
                    var x = e.clientX;
                    var y = e.clientY;
                    that.scene.rotation.y += (x - position.x) / 100;
                    that.scene.rotation.x += (y - position.y) / 100;
                    position.x = x;
                    position.y = y;
                    that._render();
                }
            })
            $(document).mouseup(function(e) {
                down = false;
            })
            document.onmousewheel = function(e) {
                if (e.deltaY > 0) {
                    that.camera.position.z += 0.3;
                } else {
                    that.camera.position.z -= 0.3;
                }
                that._render();
            }
        },
        _render: function() {
            // this.scene.rotation.x=Math.PI/4
            this.renderer.render(this.scene, this.camera);
        },
        _initcontrols: function() {
            this.controls = new THREE.OrbitControls(this.earth);
            this.controls.autoRotate = true;
            // this.controls.autoRotateSpeed=5.0;
            this.controls.update();
        },
        animate: function() {
            requestAnimationFrame(this.animate.bind(this));
            this.stat.update();
            // this.controls.update();
            this.earth.rotation.y+=0.01;
            this.uniforms.u_time.value += 0.05;
            // console.log(this.earth.rotation.z)
            this.earth.updateMatrix();
            // this.scene.rotation.y += 0.01;
            // for(var i=0;i<this.scene.children.length;i++){
            //     var sprite=this.scene.children[i];
            //     if(sprite.name.indexOf('snow')>-1){
            //         if(sprite.position.z<20){
            //         sprite.position.z+=0.1;
            //         sprite.position.x+=(sprite.name.substr(4)-50)/50;
            //         sprite.position.y+=(sprite.name.substr(4)-50)/50;}
            //         else{
            //             this.scene.remove(sprite);
            //             // this.addstars();
            //         }
            //     }
            // }
            this._render();
        }

    }
    root.FThree = FThree;
})(window)
var fthree = new FThree($("#three"))
var FizzyText = function() {
    this.message = 'dat.gui';
    this.speed = 0.8;
    this.displayOutline = false;
    this.intensity = 1;
    this.addcube = function() {
        fthree.addcube();
    };
    this.adddepthcube = function() {
        fthree.adddepthcube();
    };
    this.addblendcube = function() {
        fthree.addblendcube();
    };
    this.addlambercube = function() {
        fthree.addlambercube();
    };
    this.addlphongcube = function() {
        fthree.addlphongcube();
    }
    this.removecube = function() {
        fthree.removecube();
    };
    this.switchcamera = function() {
        fthree.switchcamera();
    }

    // Define render logic ...
};

window.onload = function() {
    var text = new FizzyText();
    var gui = new dat.GUI();
    gui.add(text, 'message');
    gui.add(text, 'speed', -5, 5);
    gui.add(text, 'displayOutline');
    gui.add(text, 'addcube');
    gui.add(text, 'adddepthcube');
    gui.add(text, 'addblendcube');
    gui.add(text, 'addlambercube');
    gui.add(text, 'addlphongcube');
    gui.add(text, 'removecube');
    gui.add(text, 'switchcamera');
    gui.add(text, 'intensity', 0, 3).onChange(function(e) {
        fthree.chageintensity(e);
    })
};
</script>

</html>