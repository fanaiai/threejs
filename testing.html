<!DOCTYPE html>
<html>

<head>
    <title></title>
    <style type="text/css">
    #three {
        width: 600px;
        height: 400px;
    }
    </style>
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="Lensflare.js"></script>
    <script type="text/javascript" src="QuickHull.js"></script>
    <script type="text/javascript" src="CanvasRenderer.js"></script>
    <script type="text/javascript" src="Projector.js"></script>
    <script type="text/javascript" src="SceneUtils.js"></script>
    <script type="text/javascript" src="ConvexGeometry.js"></script>
    <script type="text/javascript" src="BufferGeometryUtils.js"></script>
    <script type="text/javascript" src="tweenjs.min.js"></script>
    <!-- <script type="text/javascript" src="inflate.js"></script> -->
    <script type="text/javascript" src="FBXLoader.js"></script>
    <script type="text/javascript" src="OBJLoader.js"></script>
    <script type="text/javascript" src="stats.min.js"></script>
    <script type="text/javascript" src="dat.gui.js"></script>
</head>

<body>
    <div id="three"></div>
    <div id="Stats-output"></div>
<script type="x-shader/x-vertex" id="vertexshader">
    void main(){ 
        gl_PointSize=1.; 
        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); 
    }
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color; 
    void main(){ 
        gl_FragColor=vec4(color,1.0); 
}
</script>
</body>
<script type="text/javascript">
(function(root) {
    function FThree(el) {
        this.$el = $(el);
        this.size = { width: $(el).width(), height: $(el).height() };
        this.cubelength = 0;
        this.scene = null;
        this.renderer = null;
        this.light = null;
        this.camera = null;
        this.obj = null;
        this.stat = this._initstat();
        this.eventlists = [];
        this.init();
    }
    FThree.prototype = {
        init: function() {
            this._initrenderer();
            this._initscene();
            var axes = new THREE.AxisHelper(20);
            this.scene.add(axes);
            this._initcamera();
            // this._initaxis();
            // this._addobj();
            this.addplane();
            // this.addsphere();
            this.addcube();
            // this._initlight();
            // this.ambientlight();
            this.addpointlight();
            this.addspotlight();
            this.addlensflare();
            // this.addconvexgeo();
            // this.addlathegeo();
            // this.addparticle();
            // this.addplanegeo();
            // this.addparticleobj();
            // this.addmergeobj();
            // this.addTorusKnotGeometry();
            // this.addnormalsphere();
            // this.addmeshfase();
            // this.addhemilight();
            // this.addPointSphere();
            this.addRobot();
            this.updaterobot();
            this._render();
            this._addevent();
            // this.trigger('init')
            console.log(this.scene)
            // this.animate();
        },
        addRobot: function() {
            var that = this;
            new THREE.OBJLoader().load('models/Santa Claus Pose1/Santa_Claus_Pose1_obj.obj', function(obj) {
                var geometry = obj.children[0].geometry;
                // var material=new THREE.PointsMaterial({color:0xffff00,size:0.05});

                var uniforms = {
                    color: {
                        type: 'v3',
                        value: new THREE.Color(0xffffff)
                    }
                };
                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                })
                console.log(shaderMaterial)
                var robot = new THREE.Points(geometry, shaderMaterial);
                robot.scale.x = 0.1;
                robot.scale.y = 0.1;
                robot.scale.z = 0.1;
                robot.rotation.x = -Math.PI / 2;
                that.robot=robot;
                that.scene.add(robot)
                that._render();

            });
        },
        updaterobot:function(){
            // TWEEN.update();
            this.stat.update();
            var time=new Date()*0.005;
            if(this.robot){
            var obj=this.robot.geometry;
            // console.log(obj)
            var sizes=obj.attributes.position.array;
            var len=sizes.length;
            for(var i=0;i<len;i++){
                sizes[i]=sizes[i] + 0.1;
            }
            obj.attributes.position.needsUpdate=true;
            }
            this._render();
            requestAnimationFrame(this.updaterobot.bind(this))
        },
        addPointSphere: function() {
            var material = new THREE.PointsMaterial({ color: 0xff55ca, size: 0.1, morphTargets: true });
            var geomatry = new THREE.SphereGeometry(3, 32, 32);
            var uniforms = {
                color: {
                    type: 'v3',
                    value: new THREE.Color(0xffffff)
                }
            };
            var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            })
            var mesh = new THREE.Points(geomatry, shaderMaterial)
            mesh.position.y = 4;
            console.log(mesh)
            this.scene.add(mesh);
        },
        on: function(type, fn) {
            type = type || 'any';
            if (typeof this.eventlists[type] === "undefined") {
                this.eventlists[type] = [];
            }
            this.eventlists[type].push(fn);
        },
        trigger: function(type) {
            var l = this.eventlists[type].length;
            var returndata;
            for (var i = 0; i < l; i++) {
                returndata = this.eventlists[type][i].call(this);
            }
            return returndata;
        },
        _initstat: function() {
            var stats = new Stats();
            //设置统计模式
            stats.setMode(0); // 0: fps, 1: ms
            //统计信息显示在左上角
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            //将统计对象添加到对应的<div>元素中
            document.getElementById("Stats-output").appendChild(stats.domElement);
            return stats;
        },
        _initrenderer: function() {
            this.renderer = new THREE.WebGLRenderer({ alpha: true });
            this.renderer.setSize(this.size.width, this.size.height);
            this.renderer.setClearColor(0x000000)
            this.renderer.shadowMap.enabled = true
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.shadowMapSoft = true;
            this.$el.append(this.renderer.domElement)
        },
        _initscene: function() {
            this.scene = new THREE.Scene();
            // this.scene.fog=new THREE.FogExp2( 0xff00ff,0.15 );//雾化效果
            // this.scene.overrideMaterial=new THREE.MeshLambertMaterial( {color:0xffffff,   wireframe:false });//所有物体一个颜色
        },
        _initaxis: function() {
            var option = {
                size: 5,
                height: 10,
                weight: 'normal',
                font: 'helvetiker'
            }
            var size = 1 * 2;
            var vectors = [];
            var texts = new THREE.Group();
            var loader = new THREE.FontLoader();
            var material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
            loader.load('font1.json', function(font) {
                for (var x = 0; x <= size; x++) {
                    for (var y = x; y <= size; y++) {
                        for (var z = y; z <= size; z++)
                            var geometry = new THREE.TextGeometry('1', {
                                font: font,
                                size: 0.1,
                                height: 0.1,
                                // curveSegments: 1,
                                // bevelEnabled: true,
                                bevelThickness: 0.01,
                                // bevelSize: 8,
                                // bevelSegments: 5
                            });
                        var text = new THREE.Mesh(geometry, material);
                        text.position.set(x - size, y - size, z - size)
                        texts.add(text)
                    }
                }
            });
            console.log(texts)
            this.scene.add(texts);
        },
        _initcamera: function() {
            this.camera = new THREE.PerspectiveCamera(75, this.size.width / this.size.height, 0.1, 1000);
            this.camera.position.z = 30;
            this.camera.position.y = 15;
            this.camera.lookAt(0, 0, 0);
        },
        switchcamera: function() {
            if (this.camera instanceof THREE.PerspectiveCamera) {
                this.camera = new THREE.OrthographicCamera(this.size.width / -16, this.size.width / 16, this.size.height / -16, this.size.height / 16);
                this.camera.position.z = 15;
                this.camera.lookAt(0, 0, 0);
            } else {
                this.camera = new THREE.PerspectiveCamera(75, this.size.width / this.size.height, 0.1, 1000);
                this.camera.position.z = 15;
                this.camera.lookAt(0, 0, 0);
            }
            this._render();
        },
        _initlight: function() { //平行光
            this.light = new THREE.DirectionalLight({ color: 0xff00ff });
            // this.light.target = this.obj;
            this.light.castShadow = true;
            // this.light.shadowCameraVisible = true;
            this.light.shadowDarkness = 0.1;
            this.light.position.y = 2;
            this.light.position.x = 2;
            this.light.position.z = 2;
            this.light.shadow.mapSize.width = 128
            this.light.shadow.mapSize.height = 128
            this.scene.add(this.light);
        },
        addambientlight: function() {
            this.amlight = new THREE.AmbientLight(0x333333);
            this.amlight.position.set(2, 2, 3);
            this.amlight.intensity = 0.2;
            this.scene.add(this.amlight)
        },
        addpointlight: function() { //点光源
            this.pointlight = new THREE.PointLight({ color: 0xff0000, intensity: 2, distance: 2 });
            this.pointlight.position.set(2, 2, 2);
            this.pointlight.castShadow = false;
            this.pointlight.shadowDarkness = 0.1;
            this.pointlight.shadow.mapSize.width = 128
            this.pointlight.shadow.mapSize.height = 128
            this.scene.add(this.pointlight);
        },
        chageintensity: function(intensity) {
            this.pointlight.intensity = intensity;
        },
        addspotlight: function() { //聚光灯
            this.spotlight = new THREE.SpotLight(0xffffff);
            this.spotlight.position.set(20, 50, 20);
            this.spotlight.castShadow = false;
            this.spotlight.shadowDarkness = 1.1;
            this.spotlight.shadow.mapSize.width = 128
            this.spotlight.shadow.mapSize.height = 128
            var target = new THREE.Object3D();
            target.position = new THREE.Vector3(0, 0, 0);
            this.spotlight.target = target;
            this.scene.add(this.spotlight);
        },
        addhemilight: function() { //半球光
            this.hemilight = new THREE.HemisphereLight(0xff0000, 0x00ff00, 0.6);
            this.hemilight.position.set(0, 500, 0);
            this.scene.add(this.hemilight);
        },
        addarealight: function() { //平面光光源 从平面发射的光，太复杂了，要多加好多东西，先不看
            this.arealight = new THREE.AreaLight();

        },
        addlensflare: function() { //添加光晕
            var texture = new THREE.TextureLoader().load('lensflare0.png');

            this.lensflare = new THREE.Lensflare();
            this.lensflare.addElement(new THREE.LensflareElement(texture, 100, 0))
            this.lensflare.position = this.spotlight.position
            this.spotlight.add(this.lensflare);
        },
        addcube: function() {
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxBufferGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshPhongMaterial({ color: color, wireframe: false });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            // this.scene.add(cube);
            // this._render();
            return geometry;
            this.cubelength++;
        },
        addblendcube: function() {
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var depthmaterial = new THREE.MeshDepthMaterial();
            var colormaterial = new THREE.MeshBasicMaterial({ color: color, wireframe: false, transparent: true, blending: THREE.MultiplyBlending });
            var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry, [depthmaterial, colormaterial]);
            cube.children[0].scale.set(.99, .99, .99)
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        adddepthcube: function() { //深度着色，其外观由物体到相机距离决定，可以做成逐渐消失的样子,error
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshDepthMaterial({ fog: true });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        addlambercube: function() {
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshLambertMaterial({ color: color });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        addlphongcube: function() { //类似金属的材质
            var boxwidth = Math.random() * 1.5;
            var color = new THREE.Color('rgb(' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ',' + Math.ceil(Math.random() * 255) + ')');
            var geometry = new THREE.BoxGeometry(boxwidth, boxwidth, boxwidth);
            var material = new THREE.MeshPhongMaterial({ color: color, specular: color, shininess: 100 });
            var cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.name = 'cube' + this.cubelength;
            cube.position.x = Math.random() * 50 - 25;
            cube.position.y = Math.random();
            cube.position.z = Math.random() * 50 - 25;
            this.scene.add(cube);
            this._render();
            this.cubelength++;
        },
        addnormalsphere: function() { //法向量材质，不太懂，反正颜色怎么转都一样,也不能设置颜色
            var geometry = new THREE.SphereGeometry(5, 32, 32);
            var material = new THREE.MeshNormalMaterial({ wireframe: false, shading: THREE.SmoothShading });
            var obj = new THREE.Mesh(geometry, material);
            obj.position.x = 3;
            obj.castShadow = true;
            this.scene.add(obj);
        },
        addshadercube: function() { //着色器材质，最复杂的材质，也是最有用的，后面详细看

        },
        addplanegeo: function() {
            var geometry = new THREE.PlaneGeometry(5, 5, 20);
            this.createMesh(geometry, 1, 1, 1);
        },
        addmeshfase: function() {
            var map = new THREE.TextureLoader().load('1.png');
            var map1 = new THREE.TextureLoader().load('b.png');
            map1.wrapS = THREE.RepeatWrapping;
            map1.wrapT = THREE.RepeatWrapping;
            map1.repeat.set(4, 4);
            var metarry = [];
            for (var i = 0; i < 6; i++) {
                metarry.push(new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, blending: THREE.MultiplyBlending, transparent: true }));
            }


            // var material=new THREE.MeshFaceMaterial( metarry );
            // var material=new THREE.MeshBasicMaterial({color:0xff0000,transparent:true});
            var material = new THREE.MeshBasicMaterial({ map: map1, transparent: true });
            material.blending = THREE.NormalBlending;
            material.blendEquation = THREE.SubtractEquation; //default
            material.blendSrc = THREE.SrcAlphaFactor; //default
            material.blendDst = THREE.OneMinusSrcAlphaFactor; //default
            var mapmaterial = new THREE.MeshBasicMaterial({ map: map })
            var depthmaterial = new THREE.MeshDepthMaterial();
            var geometry = new THREE.CubeGeometry(3, 3, 3);
            // var cube=new THREE.Mesh(geometry,material);
            var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry, [material, mapmaterial])
            cube.children[1].scale.set(0.99, 0.99, 0.99);
            cube.position.set(0, 0, 9);
            this.scene.add(cube);
        },
        createMesh: function(geometry, x, y, z) {
            var meshMaterial = new THREE.MeshNormalMaterial();
            meshMaterial.side = THREE.DoubleSide;
            var wireFrameMaterial = new THREE.MeshBasicMaterial({ wireframe: true, color: 0xff0000 });
            var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [meshMaterial, wireFrameMaterial]);
            // var mesh=new THREE.Mesh(geometry,wireFrameMaterial)
            mesh.position.set(x, y, z)
            this.scene.add(mesh);
        },
        removecube: function() {
            if (this.scene.children[this.cubelength - 1] instanceof THREE.Mesh) {
                this.scene.remove(this.scene.children[this.cubelength - 1])
                this._render();
                this.cubelength--;
            }
        },
        addsphere: function() {
            var geometry = new THREE.SphereGeometry(5, 32, 32);
            var material = new THREE.MeshPhongMaterial({ color: 0x00aa34, wireframe: false });
            var obj = new THREE.Mesh(geometry, material);
            obj.position.x = 3;
            obj.castShadow = true;
            this.scene.add(obj);
        },
        addplane: function() {
            var geometry = new THREE.BoxGeometry(50, 50, 0.1);
            var material = new THREE.MeshLambertMaterial({ color: 0xefefef, wireframe: false, side: THREE.DoubleSide });
            var cube = new THREE.Mesh(geometry, material);
            cube.receiveShadow = true;
            cube.rotation.x = Math.PI / 2;
            cube.position.y = -1;
            this.scene.add(cube);
        },
        addconvexgeo: function() { //画一个凸起的包
            var convexgeo = new THREE.ConvexGeometry(this.generatelathepoints());
            var material = new THREE.MeshPhongMaterial({ color: 0xff00ff, transparent: true, opacity: 0.2 });
            var mesh = new THREE.Mesh(convexgeo, material);
            this.scene.add(mesh);
        },
        addTorusKnotGeometry: function() {
            var geometry = new THREE.TorusKnotGeometry(5, 1, 100, 16);
            var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            var torusKnot = new THREE.Mesh(geometry, material);
            this.scene.add(torusKnot);
        },
        generatePoints: function() {
            var that = this;
            var points = [];
            for (var i = 0; i < 20; i++) {
                var x = -15 + Math.round(Math.random() * 30);
                var y = -15 + Math.round(Math.random() * 30);
                var z = -15 + Math.round(Math.random() * 30);
                points.push(new THREE.Vector3(x, y, z))
            }
            spGroup = new THREE.Object3D();
            var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            points.forEach(function(point) {
                var spGeom = new THREE.SphereGeometry(0.1);
                var spMesh = new THREE.Mesh(spGeom, material);
                spMesh.position.x = point.x;
                spMesh.position.y = point.y;
                spMesh.position.z = point.z;
                spMesh.name = point.x;
                spGroup.add(spMesh);
            });
            this.scene.add(spGroup);
            return points;
        },
        addlathegeo: function() { //根据点绘制平滑曲线
            var convexgeo = new THREE.LatheGeometry(this.generatelathepoints())
            var material = new THREE.MeshPhongMaterial({ color: 0xff00ff, transparent: true, opacity: 1 });
            var mesh = new THREE.Mesh(convexgeo, material);
            this.scene.add(mesh);
        },
        generatelathepoints: function() {
            var points = [];
            var height = 5;
            var count = 30;
            for (var i = 0; i < count; i++) {
                points.push(new THREE.Vector3((Math.sin(i * 1.2) + Math.cos(i * 1.3)) * height + 12, 0, (i - count) + count / 2));
            }
            return points;
        },
        addparticle: function() { //points 粒子
            // var starsGeometry = new THREE.Geometry();

            // for ( var i = 0; i < 100; i ++ ) {

            //     var star = new THREE.Vector3();
            //     star.x = THREE.Math.randFloatSpread( 100 );
            //     star.y = THREE.Math.randFloatSpread( 100 );
            //     star.z = THREE.Math.randFloatSpread( 100 );

            //     starsGeometry.vertices.push( star );

            // }

            var geometry = new THREE.SphereGeometry(1)
            var material = new THREE.PointsMaterial({ color: 0xffaa00 });
            for (var x = -5; x < 5; x++) {
                for (var y = -5; y < 5; y++) {
                    var particle = new THREE.Points(geometry, material);
                    particle.position.set(x * 3, y * 3, 0);
                    this.scene.add(particle);
                }
            }
            // this.on('init',this.addparticle);
        },
        addspirit: function() {
            var canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            var texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        },
        createpaticlesystem(geometry) {
            var material = new THREE.PointsMaterial({ color: 0xaacc22, size: 3, transparent: true, map: this.addspirit() });
            var system = new THREE.Points(geometry, material);
            // system.sortParticles=true;
            return system;
        },
        addparticleobj: function() { //把一个几何体用粒子画出来
            // var geometry=new THREE.TorusKnotGeometry( 30, 2, 8, 8, 2, 3 );
            // var knot=this.createpaticlesystem(geometry);
            // this.scene.add(knot);
            var map = new THREE.TextureLoader().load('img/earth_1.png');
            var colormaterial = new THREE.MeshBasicMaterial({ wireframe: false, transparent: true, blending: THREE.MultiplyBlending, map: map });

            var geometry = new THREE.TorusKnotGeometry(5, 1, 100, 16);
            // var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
            var material = new THREE.PointsMaterial({ color: 0xffcc22, size: 0.2, transparent: true, opacity: 0.5, map: map });
            // var torusKnot = new THREE.SceneUtils.createMultiMaterialObject(geometry, [material]);
            var torusKnot = new THREE.Points(geometry, material);
            // var torusKnot = new THREE.Mesh( geometry, material );
            this.scene.add(torusKnot);
        },
        addmergeobj: function() { //一次添加多个几何体，不知道怎么弄
            var geometries = new THREE.BoxBufferGeometry(2, 2, 2);
            console.log(THREE.BufferGeometryUtils)
            for (var i = 0; i < 40; i++) {
                THREE.BufferGeometryUtils.mergeBufferGeometries([this.addcube()])
            }
            console.log(geometries)
            var material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            var mesh = new THREE.Mesh(geometries, material);
            this.scene.add(mesh);
        },

        _addevent: function() {
            var that = this;
            var down = false;
            var position = {};
            $(document).mousedown(function(e) {
                down = true;
                position.x = e.clientX;
                position.y = e.clientY;
            })
            $(document).mousemove(function(e) {
                if (down) {
                    var x = e.clientX;
                    var y = e.clientY;
                    that.scene.rotation.y += (x - position.x) / 100;
                    that.scene.rotation.x += (y - position.y) / 100;
                    position.x = x;
                    position.y = y;
                    that._render();
                }
            })
            $(document).mouseup(function(e) {
                down = false;
            })
            document.onmousewheel = function(e) {
                if (e.deltaY > 0) {
                    that.camera.position.z += 0.3;
                } else {
                    that.camera.position.z -= 0.3;
                }
                that._render();
            }
        },
        _render: function() {
            // this.scene.rotation.x=Math.PI/4
            this.renderer.render(this.scene, this.camera);
        },
        animate: function() {
            requestAnimationFrame(this.animate.bind(this));
            this.stat.update();
            this.scene.rotation.y += 0.01;
            this._render();
        }

    }
    root.FThree = FThree;
})(window)
var fthree = new FThree($("#three"))
var FizzyText = function() {
    this.message = 'dat.gui';
    this.speed = 0.8;
    this.displayOutline = false;
    this.intensity = 1;
    this.addcube = function() {
        fthree.addcube();
    };
    this.adddepthcube = function() {
        fthree.adddepthcube();
    };
    this.addblendcube = function() {
        fthree.addblendcube();
    };
    this.addlambercube = function() {
        fthree.addlambercube();
    };
    this.addlphongcube = function() {
        fthree.addlphongcube();
    }
    this.removecube = function() {
        fthree.removecube();
    };
    this.switchcamera = function() {
        fthree.switchcamera();
    }

    // Define render logic ...
};

window.onload = function() {
    var text = new FizzyText();
    var gui = new dat.GUI();
    gui.add(text, 'message');
    gui.add(text, 'speed', -5, 5);
    gui.add(text, 'displayOutline');
    gui.add(text, 'addcube');
    gui.add(text, 'adddepthcube');
    gui.add(text, 'addblendcube');
    gui.add(text, 'addlambercube');
    gui.add(text, 'addlphongcube');
    gui.add(text, 'removecube');
    gui.add(text, 'switchcamera');
    gui.add(text, 'intensity', 0, 3).onChange(function(e) {
        fthree.chageintensity(e);
    })
};
</script>

</html>