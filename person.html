<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - interactive - raycasting - points</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        color: #ffffff;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
    }

    #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;
    }

    a {
        color: #fff;
    }
    #canvas{
    	position: absolute;
    	background: #fff;
    	top:0;
    	right: 0;
    }
    </style>
</head>

<body>
	<canvas id="canvas"></canvas>
    <div id="container"></div>
    <div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive - raycasting - points </div>
    <script src="three.js"></script>
    <script src="Detector.js"></script>
    <script src="ObjLoader.js"></script>
    <script src="stats.min.js"></script>
    <script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();

    var renderer, scene, camera, stats;
    var pointclouds;
    var raycaster;
    var mouse = new THREE.Vector2();
    var intersection = null;
    var spheres = [];
    var spheresIndex = 0;
    var clock;

    var threshold = 0.1;
    var pointSize = 0.05;
    var width = 100;
    var length =400;
    var imgdata=[];
    var rotateY = new THREE.Matrix4().makeRotationY(0.005);
    var person=null;
    init();
    animate();
    
    function loadperson(scene){
        new THREE.OBJLoader().load('models/Santa Claus Pose1/Santa_Claus_Pose1_obj.obj', function(obj) {
                person = obj.children[0].geometry;
                console.log(person)
                var material = new THREE.MeshBasicMaterial( {color:0xff0000,wireframe:true,transparent:true,depthTest:0,vertexColors:THREE.VertexColors} );
                var line = new THREE.Mesh(person,material);
                line.scale.set(0.07,0.07,0.07)
                line.rotation.set(-Math.PI/2,0,0)
                line.position.set(0,-5,0)
                scene.add( line );
            })
    }

    function init() {

        var container = document.getElementById('container');

        scene = new THREE.Scene();


        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(10, 0, 10);
        camera.lookAt(scene.position);
        camera.updateMatrix();
        

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        loadperson(scene);
        container.appendChild(renderer.domElement);

        //

        raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = threshold;

        //

        stats = new Stats();
        container.appendChild(stats.dom);

        //

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);

    }

    function onDocumentMouseMove(event) {

        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {

        requestAnimationFrame(animate);

        render();
        stats.update();

    }

    var toggle = 0;

    function render() {

        camera.applyMatrix(rotateY);
        camera.updateMatrixWorld();

        // raycaster.setFromCamera(mouse, camera);

        // var intersections = raycaster.intersectObjects(pointclouds);
        // intersection = (intersections.length) > 0 ? intersections[0] : null;

        // if (toggle > 0.02 && intersection !== null) {

        //     spheres[spheresIndex].position.copy(intersection.point);
        //     spheres[spheresIndex].scale.set(1, 1, 1);
        //     spheresIndex = (spheresIndex + 1) % spheres.length;

        //     toggle = 0;

        // }

        // for (var i = 0; i < spheres.length; i++) {

        //     var sphere = spheres[i];
        //     sphere.scale.multiplyScalar(0.98);
        //     sphere.scale.clampScalar(0.01, 1);

        // }

        // toggle += clock.getDelta();

        renderer.render(scene, camera);

    }
    </script>
</body>

</html>