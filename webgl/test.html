<!DOCTYPE html>
<html>
<head>
	<title></title>
   <meta charset="utf-8">
   <style type="text/css">
      canvas{
         width: 600px;
         height: 400px;
         border:1px solid #ccc;
         /*background: red;*/
      }
   </style>
</head>
<body>
	<div>
		<canvas id="c">
			
		</canvas>
	</div>
	<script id="vertex-shader" type="notjs">
      attribute vec2 a_position;
      uniform vec2 u_resolution;
		void main(){
      vec2 zeroToOne=a_position/u_resolution;

      vec2 zeroToTwo=zeroToOne * 2.0;
      vec2 clipSpace=zeroToTwo - 1.0;

		gl_Position=vec4(clipSpace*vec2(1,-1),0,1);
	}
	</script>
	<script id="fragment-shader" type="notjs">
		precision mediump float;

      uniform vec4 u_color;
		void main(){
		gl_FragColor=vec4(100,100,0,1);
	}
	</script>
</body>
<script>
   var canvas=document.getElementById("c");
   canvas.width=1200;
   canvas.height=800;
   var gl=canvas.getContext("webgl");
   console.log(gl)
   if(gl){
   		function createShader(gl,type,source){

            //创建一个shader
   			var shader=gl.createShader(type);

            //为这个shader添加数据源
   			gl.shaderSource(shader,source);

            //编译shader
   			gl.compileShader(shader);

            //获取着色器的参数
   			var success=gl.getShaderParameter(shader,gl.COMPILE_STATUS);
   			if(success){
               //返回着色器
   				return shader;
   			}
   			console.log(gl.getShaderInfoLog(shader));
   			gl.deleteShader(shader);
   		}

         //获取顶点着色器内容
   		var vertexShaderSource=document.getElementById("vertex-shader").text;

         //获取片段着色器内容
   		var fragmentShaderSource=document.getElementById("fragment-shader").text;

         //创建顶点着色器
   		var vertexShader=createShader(gl,gl.VERTEX_SHADER,vertexShaderSource);

         //创建片段着色器
   		var fragmentShader=createShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource);

   		function createProgram(gl,vertexShader,fragmentShader){

            //创建着色程序
   			var program=gl.createProgram();

            //添加定义好的顶点着色器和片段着色器
   			gl.attachShader(program,vertexShader);
   			gl.attachShader(program,fragmentShader);

            //将顶点着色器和片段着色器链接到一起
   			gl.linkProgram(program);
   			var success=gl.getProgramParameter(program,gl.LINK_STATUS);
   			if(success){
   				return program;
   			}
   			console.log(gl.getProgramInfoLog(program));
   			gl.deleteProgram(program);
   		}

         //创建着色器程序
   		var program=createProgram(gl,vertexShader,fragmentShader);


         //为着色器添加一个属性
   		var positionAttributeLocation=gl.getAttribLocation(program,"a_position");

         //为着色器添加另一个属性
         var resolutionUniformLocation=gl.getUniformLocation(program, "u_resolution");

         //创建一个缓冲区
         var positionBuffer=gl.createBuffer();

         //绑定缓冲区https://www.cnblogs.com/dbylk/p/4492306.html
         gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);

         //定义数据
         var positions=[
            0,0,
            100,100,
            100,0,
            0,100,
            0,0,
            100,100,
         ];

         //向缓冲区存放数据
         gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);


         //以下代码为渲染代码，次次执行
         //设置canvas可视区尺寸
         gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
         gl.clearColor(255,255,255,1);
         gl.clear(gl.COLOR_BUFFER_BIT);

         //应用着色程序
         gl.useProgram(program);
         //启用定义的属性
         gl.enableVertexAttribArray(positionAttributeLocation);
         // 将绑定点绑定到缓冲数据（positionBuffer）
         gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);


         var size=2;
         var type=gl.FLOAT;
         var normalize=false;
         var stride=0;
         var offset=0;
         gl.vertexAttribPointer(positionAttributeLocation,size,type,normalize,stride,offset);

         gl.uniform2f(resolutionUniformLocation,gl.canvas.width,gl.canvas.height);
         var primitiveType=gl.TRIANGLES;
         var offset=0;
         var count=6;
         gl.drawArrays(primitiveType  ,offset,count);
         
   }
</script>

</html>